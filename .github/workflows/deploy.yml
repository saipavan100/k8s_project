name: CI/CD - Build & Deploy to Kubernetes

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  ACR_REGISTRY: ${{ secrets.ACR_NAME }}.azurecr.io
  IMAGE_NAME_BACKEND: myapp-backend
  IMAGE_NAME_FRONTEND: myapp-frontend
  NAMESPACE: winonboard
  RELEASE_NAME: myapp

jobs:
  build-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_NAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and push backend image
        run: |
          docker build -t ${{ env.ACR_REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }} ./backend
          docker tag ${{ env.ACR_REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }} ${{ env.ACR_REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest
          docker push ${{ env.ACR_REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}
          docker push ${{ env.ACR_REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest

  build-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_NAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and push frontend image
        run: |
          docker build -t ${{ env.ACR_REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }} ./frontend
          docker tag ${{ env.ACR_REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }} ${{ env.ACR_REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:latest
          docker push ${{ env.ACR_REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}
          docker push ${{ env.ACR_REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:latest

  deploy-helm:
    needs: [build-backend, build-frontend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'

      - name: Configure kubectl
        env:
          KUBECONFIG_CONTENT: ${{ secrets.KUBECONFIG }}
        run: |
          mkdir -p $HOME/.kube
          echo "$KUBECONFIG_CONTENT" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          kubectl cluster-info

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Kubernetes secrets from GitHub secrets
        run: |
          # Delete old secret if it exists (to avoid Helm ownership conflict)
          kubectl delete secret ${{ env.RELEASE_NAME }}-secret -n ${{ env.NAMESPACE }} --ignore-not-found=true
          
          # Create new secret
          kubectl create secret generic ${{ env.RELEASE_NAME }}-secret \
            --from-literal=MONGODB_URI="${{ secrets.MONGODB_URI }}" \
            --from-literal=JWT_SECRET="${{ secrets.JWT_SECRET }}" \
            --from-literal=JWT_EXPIRE="${{ secrets.JWT_EXPIRE }}" \
            --from-literal=EMAIL_HOST="${{ secrets.EMAIL_HOST }}" \
            --from-literal=EMAIL_PORT="${{ secrets.EMAIL_PORT }}" \
            --from-literal=EMAIL_USER="${{ secrets.EMAIL_USER }}" \
            --from-literal=EMAIL_PASSWORD="${{ secrets.EMAIL_PASSWORD }}" \
            --from-literal=EMAIL_FROM="${{ secrets.EMAIL_FROM }}" \
            --from-literal=ADMIN_EMAIL="${{ secrets.ADMIN_EMAIL }}" \
            --from-literal=ADMIN_PASSWORD="${{ secrets.ADMIN_PASSWORD }}" \
            --from-literal=AZURE_OPENAI_ENDPOINT="${{ secrets.AZURE_OPENAI_ENDPOINT }}" \
            --from-literal=AZURE_OPENAI_API_KEY="${{ secrets.AZURE_OPENAI_API_KEY }}" \
            -n ${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create ACR pull secret
        run: |
          kubectl create secret docker-registry acr-secret \
            --docker-server=${{ env.ACR_REGISTRY }} \
            --docker-username=${{ secrets.ACR_NAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            -n ${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy with Helm (upgrade or install)
        run: |
          helm upgrade --install ${{ env.RELEASE_NAME }} ./win_k8s \
            -n ${{ env.NAMESPACE }} \
            -f win_k8s/values-template.yaml \
            --set backend.tag=latest \
            --set frontend.tag=latest \
            --wait \
            --timeout 5m

      - name: Verify deployment
        run: |
          echo "=== Checking Pod Status ==="
          kubectl get pods -n ${{ env.NAMESPACE }}
          
          echo "=== Checking Services ==="
          kubectl get svc -n ${{ env.NAMESPACE }}
          
          echo "=== Checking Ingress ==="
          kubectl get ingress -n ${{ env.NAMESPACE }}
          
          echo "=== Rollout Status ==="
          kubectl rollout status deployment/${{ env.RELEASE_NAME }}-backend -n ${{ env.NAMESPACE }} --timeout=3m || true
          kubectl rollout status deployment/${{ env.RELEASE_NAME }}-frontend -n ${{ env.NAMESPACE }} --timeout=3m || true
